\documentclass[11pt,fullpage]{article}
\usepackage{graphicx}
\usepackage{fullpage}
 
\usepackage{amsmath}
\usepackage{mathtools}

\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=2pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=1
}
\lstset{style=mystyle}

%\usepackage{afterpage}
%\usepackage{fullpage}
%
% \usepackage{fancyhdr}
% \pagestyle{fancy}
% \rhead{Y.  Ben Asher  No.1438/17}
% \lhead{}


\begin{document}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \newtheorem{theorem}{Theorem}[section]
 \newtheorem{corollary}{Corollary}[section]
 \newtheorem{lemma}{Lemma}[section]
 \newtheorem{exercise}{Exercise}
 \newtheorem{claim}{Claim}[section]
 \newtheorem{definition}{Definition}[section]
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %\hsize=6in
 %\vsAXe=9in
 %indent=.25in
 %skip=.080in
 %\baselineskip=.05in
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def \n { \{1..n \} }
\def\proof{\noindent{\bf Proof:~}}
\def\Proof{\noindent{\bf Proof:~}}
\def\blackslug{\hbox{\hskip 1pt \vrule width 4pt height 8pt
    depth 1.5pt \hskip 1pt}}
\def\QED{\quad\blackslug\lower 8.5pt\null\par}
\def\mul {\times}
\def \lr {\longrightarrow}
\def \sr {\longrightarrow}
\def \Lr {\longleftarrow}
\def \dr {{\downarrow}}
\def \bs {\backslash }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand \nxt[1]{
             \stackrel{#1}{\lr}
}
 
\newcommand \sss[1]{
            \begin{array}[t]{l}
             #1\stackrel{\mbox{\tiny no}}{\lr}\\
             \dr
            \end{array}
}
\newcommand {\spp}[1] {
           \begin{picture}(30,30)
           \put(10,20){\sequence(1,0){20}}
           \put(10,20){\sequence(0,-1){20}}
           \put(16,22){n}
           \put(6,10){y}
           \put(0,22){#1}
           \end{picture}
         }
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\utrans}[3]{
\begin{center}\tt
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{|p{#3 mm}|}
\hline
\vspace*{-3ex}~\parbox{0pt}{\begin{tabbing} #1 \end{tabbing}} \\ \hline
#2 \\
\hline
\end{tabular}
\end{center}
}

%
\title{Scheduling on restricted uniformly related machines.}
\author{Ebrahim Kashkoush\\
      }

\date{}

\maketitle

\section{Abstract}

in this project we try to solve scheduling problem using three Heuristics Local search,Branch and bound and genetic heuristic,we write three unattached projects in each one we use one heuristic,we can get better  and faster algorthim by Combine more than one heuristic or by using more complex algorthims like evaluate pairs of chromosomes instead of chromosomes ,and use more complex target function in genitic. but the main idea of the project was to learn the basic concept of the following heuristics.\newline

The problem is Scheduling on restricted uniformly related machines. where the Input is An integer number of machines m $\geq$ 2. A set of n jobs J=\{1,2,...,n\} 
where job j has an integer processing time  $P_j > 0$ Machines speeds $s_i \in \{1,2,4\}$  for i= 1,2,...,m , we solve the same problem in the three heuristics
\section{Local Search}
The local search algorthim It consists of several steps we will Explain the algorithm step by step
\subsection{pre preparing(initial solution)}
to start running the local search algorthim  first we need initial solution. we have as input two file the first file is for tasks where we have on each line  task time (integer value) ,  the second file is for machines where each line contains machine speed    (integer 1,2,4). from the input we build two vectors the first one hold the tasks and the second hold the machines . after having data structure hold the tasks and the machines we should Hand out the tasks into  the machines and make initial soulation , so we need  greedy algorithm  its not important how many the greedy algorthim is good. also if we hand out the task randomly at the end we will have the same result ,  so for convenience we insert the numbers to minmum heap  to sort the tasks and then we Turned on the tasks into machines In a fair way (In a circular) and on each time  we give the same amount tasks as the current machine speed value to the machine , for example if we have machine with speed 2 we will give it two task each time ,and if the machine speed 4 we will give it 4 tasks each time . we do that while we still have tasks, and when we hand out all the tasks
we have an initial solution.
\subsection{Local Search for two machines}
on this subsection and on the next subsections we will solve small problems and then we will combine all of them together in the last subsection creating the full problem solution. \newline
the current problem is given two machines $m_1$  and $m_2$ we want to find the best tasks from $m_1$  and $m_2$   that if we
swap them bettwen  $m_1$  and $m_2$  we get the best Improvement to achive the Goal . so now we should define what is the goal that we want to achive.\newline
givin two machines   $m_1$  and $m_2$ where the time of $m_1$ is X and the time of $m_2$ is Y . let assume that we chose $k$ tasks from $m_1$ and $r$ tasks from $m_2$  now we should evaluate the time after swapping the tasks (simulation) between the two machines by passing $k$ tasks from $m_1$ to $m_2$ and removing the $k$ tasks from $m_1$ ,and the same by passing $r$ tasks from $m_2$ to $m_1$ and removing the tasks from $m_2$. lets define the time of $m_1$ after the change is A and the time of $m_2$ after the change (swaping the tasks) is B . the our goal that we want to achive:\newline
 (max\{A,B\}$<$max\{X,Y\} $ ||$ ( max\{A,B\}=max\{X,Y\}  and (A+B)$<$(X+Y))) \newline
that measn if we save the best soulation and we find new soultion by swaping $k , r$ tasks bettwen $m_1$ and $m_2$ and that soulation  better than the best soulation for now, we save it as the best soulation and we save $r, k$ tasks and then we check the other $k, r$ compinition with the
new best solution after we check all possible to choice  $r, k$ we have the best $r,k$ that by swaping them we achive our goal NOTE($k $ and $ r$ is constant).\newline
the idea of adding ( max\{A,B\}=max\{X,Y\}  and (A+B)$<$(X+Y)) is to give priority to machines with high speed we want to fill machines with high speed also 
if the final soulation still the same (max\{A,B\}), because that help us to find bigger task to swap in the future.
\subsection{All posible combination of r,k}
as we saw in previous section we need to go through all possible  combinations of choosing $k$ tasks from $m_1$ (the same about $r$) as we know from mathematics we have  $\binom{n}{k}$ different combination. where $n$ is the number of tasks on $m_1$ and $k$ is the number of taskt that we want to choose from $m_1$ to swap them.\newline
we can solve the combination problem easily by using recursion and array with size $k$  (int data[k]) , we go through all the $n$ tasks we start from first task (first function call) and we call the function recursively twice the first call with array data that we add to it task1 and the second one with array data without adding to it task1, in general in the $p$ funcion $call$ we call the function recursively twice ,the first time with adding $task_k$ to data array and the second with out adding it.
and when data array full we fill al the k cells we have new  combination.\newline
in other words the idea that each task has two possibilities the first one is to be part of the combination and the second its not part of the combination.
\subsection{combination of two machines}
i go throw all possible cobinations of two machines twice on deferent order the code is so easy so writing the code more sample than to dscribe it :\newline 
\lstinputlisting[language=c]{e.txt}
\subsection{all togther} 
we show above how to go  throw all posible combination of pair of two machine.  and on each  combination of two machines  how to go throw all possible combination of $k$ tasks from $m_1$ and $r$ tasks from $m_2$ (where $k$ and $r$ is constant) and how to choose the best combination of choosing $k$,$r$(how we applay LocalSearch on this two machines) (we check all the combination of choose $k$ from $machine_1$ with all the combination of choose $r$ from $machine_2$ "each combination from $machine_1$ with all the combination of $machine_2$ ")

so we can write one function $LocalSearchNxM(k,r)$ and applied LocalSearch that swap $k$ tasks from first machine with $r$ from second machine  and we go throw all compinition of two machine like we said above \newline
this is the main LocalSearch Function:\newline
Where: \newline
LevelZero(): is function implement local search that only pass one task each time from $machine_1$ to $machine_2$ with the same rolles above.\newline
 LocalSearchNxM(k,r): function implement localsearch where we want swap each time $k$ tasks from $m_1$ with $r$ tasks from $m_2$ \newline
we stop the while if we go throw all the levels and there is no improvement.and print the result
 \lstinputlisting[language=c]{Local.txt}

\section{Branch and bound}
on this heuristic we should build tree, each node on the tree have lower bound and higher bound , each edge bettwen father and son represent handing out task to the son, where each node represent machine , so each father has at most children's as the number of machines, so the path from the root to each node in the level-$k$ (node with deapth $k$) represent handing out the first $k$ task where $edge_j$ represent handing out $task_j$  , but we will not build all the tree because if there node that have lower bound equal or greater than any upper bound on any node on the tree there is no need to continue to his son's becouse we will not get better soultion than the node with the upper bound, for that reason we have also a global upper bound that his value is the minimum value on all  the upper bounds that we have on all the nodes that we build to that point.(on building each node we update his value if the node upper bound is less). upper bound can be greedy algorithm but unlike Loca search the greedy algorithm is important because bad greedy algorithm mean that we need to build more node on the tree, and as result we will have to wait more time to get the solution, so here for example its good idea to set the result of local search as upper bound but we did not do that because  most of the time we get optimal soultion using local search because  our goal to learn the  heuristic and to find the best way to calculate the upper and lower bounds.\newline
so our greedy algorthim is LPT ( Longest Processing Time Algorithm) . also the sequence of the tasks on branch and bound algorthim is important by handing out the big tasks first can help us to build less nodes because  the lower bound grow and get bigger faster, also this issue
\bibliographystyle{plain}
 
\bibliography{pr}
\end{document}

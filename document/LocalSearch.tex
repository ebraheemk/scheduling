\documentclass[a4paper,12pt]{report}
 
 
\usepackage{amsmath}
\usepackage{mathtools}

\begin{document}  
  \title{Local Search for scheduling }
\author{Ebraheem Kashkoush}
\date{\today}
\maketitle
  \section{Abstract}
In this project we use Local Search to solve scheduling problime, the problem is : \newline
Scheduling on restricted uniformly related machines.\newline 
Input:An integer number of machines m $\geq$ 2. A set of n jobs J=\{1,2,...,n\} 
where job j has an integer processing time  $P_j > 0$ Machines speeds $s_i \in \{1,2,4\}$  fori= 1,2,...,m\newline
Goal:Find a partition (assignment) of the jobs into non-empty subsets $I_1,I_2,...,I_m$
Objective:...\par . \newline
 
Note: it's not the best way to solve the problem using Local Search but i use this problem to build  example of using Local Search we can get better soloution by using compination of B\&B and Local Search for example.\newline
in my soloution some time it enter to local minimum for that reason we will discuss on the future work how we can solve this problem and also how to optimize the algorthim run time.\par 

  \section{algorthim}
\subsection{initial soloution}
\begin{itemize}
\item first we read the input files,we have two inputs the first one for tasks each line in input file has task time value ,and the second file for machines each line have the speed of new machine.\newline
we enter the input into two vectors 1- vector$<$Node$>$ J , and 2- vector$<$machin$>$ M ,where J hold tasks (Node hase two value : index and task time) ,and M hold machines \newline
each machine has :\newline 
int speed :-  hold machine speed \{1,2,4\}\newline
	int TasksTime; :- hold the total tasks time\newline
	int index :- hold machine index\newline
	std::map$<$int,Node$>$ Tasks :- map that hold the  Tasks chossed for the machine by scheduler.\newline
\textbf{Note:} We chosed hash map becouse we will try to change tasks bettwen each two posible machines ,and hash map has best  complixity for finding task by index, becouse must of the time we only check and did not 
swap the tasks bettwen one machine to othere (only if swaping the tasks from one machine to other make us more close to the goal )we change the tasks bettwen two machines (and this probability is unlikly).\newline
but as result we have a problem when we want to chose k tasks frome $machine_1$ and r tasks from $machine_2$ we dont now witch indxes in each machine so we build an 2D array hold the indxes ,its ok to hold array
becouse only if we swap the tasks we remalloc the rows of this two machine and update the row and we said before that  probability is unlikly\par
\item then we enter the tasks into Min\_Heap .\newline
and while te MinHeap is not empty we   do  sequentially loop for machines each time we gave each machine tasks count the same as the machine speed for if the machine speed 1 we give at 1 task and if the machine speed
2 we give it 2 tasks etc... .\newline
that was the initial solotion and on that soloution we applay the LocalSearch algorthim
\end{itemize}
\subsection{Local Search of two machines} 
givin two machines m1 and m2 , we want to find the best tasks that if we swap them bettwen m1 and m2 we get the best Improvement to achive the Goal .\newline
where the goal is :\newline
 let assume that we chose $k$ tasks from $m1$ and $r$ tasks from $m2$ ,  and A,B is the time of machines $m1,m2$ after swaping the tasks ($r $from$ m2$ ,$k$ from $m1$)and X,Y is the time before sewaping the tasks .\newline 
we chose $k$ task from all posible compination to chose $k$ tasks from $m1$ and $r$ tasks  from all posible compination in $m2$ such that give as: .\newline
   max\{A,B\}$<$max\{X,Y\}  or ( max\{A,B\}=max\{X,Y\}  and (A+B)$<$(X+Y)) .\newline
that mean we go throw the compination sequentially if the new  $r,k$ give us maximum machine timing less than the best soloution  for $m1,m2$ or the same maximum but the sum of A+B$<$X+Y we chose the new $r,k$ as the best soloution for now and save $r,k$ and check the other $k,r$   compinition with the new best solution.\newline
Note: the    ( max\{A,B\}=max\{X,Y\}  and (A+B)$<$(X+Y))  equation help us to give high priority to machines with high speed.\newline
Above we describe one iteration but we repeat the iteration untill we can not find $r,k$ that give us best soloution if we swap  them. and then we stop the Local search bettwen $m1$ and $m2$\newline
\subsection{All posible combination } 


\end{document}
 